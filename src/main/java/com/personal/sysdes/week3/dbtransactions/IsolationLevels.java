package com.personal.sysdes.week3.dbtransactions;

import com.personal.sysdes.utils.PostgresDBConnection;
import com.personal.sysdes.utils.Utils;
import com.personal.sysdes.utils.WaitGroup;
import com.personal.sysdes.week1.blockingqueue.BlockingQueue;

import java.sql.*;

/**
 * This exercise was to understand (and implement) different isolation levels in postgres.
 * This is one of the blog post which explains these concepts in detail -
 * <a href="https://postgrespro.com/blog/pgsql/5967856">Postgres Isolation and MVCC</a>
 * SQL Standard defined a certain set of anomalies which can occur, and at what isolation "level", those anomalies
 * (or subset) are tolerable.
 *
 * The anomalies are as follows -
 * 1. Lost Update - If two trxs are working on the same set of rows, and an update is lost by over-writing.
 * 2. Dirty Read - If a trx(T2) reads "uncommitted" data of another trx(T1) and T1 rollbacks.
 * 3. Non-repeatable read - If a trx(T1) commits in between another trx (t2), after trx(T2) first
 *              read to be updated data. The read is not repeatable anymore.
 * 4. Phantom read - If a trx (T1) reads a set of rows by a condition, and then another transaction adds a row which
 *              would had been eligible by the filter of T1, then T1 would get extra row from its filter.
 * 5. No anomalies at all!!
 *
 * An important point to note, the above anomalies are defined in the standard, but in practice there are many more
 * anomalies that can occur, at many different isolation levels, except for the 5th state isolation level (Serializable).
 *
 * <p>
 * Postgres (and maybe others -- need to read) uses MVCC (multi version concurrency control -
 * <a href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control">Wikipedia (MVCC)</a>)
 * which gives a certain guarantees out of the box. Lost update and read Dirty reads are avoided altogether with MVCC.
 *
 * And hence, there are 3 isolation levels to be configured at the start of the transaction.
 * 1. Read committed - Allows non-repeatable read and phantom.
 * 2. Repeatable read - Allows phantom.
 * 3. Serializable - Allows no anomalies.
 *
 */
public class IsolationLevels {

    final BlockingQueue bq;


    public IsolationLevels() throws InterruptedException, SQLException {
        // Drop DB if exists (idempotent)
        // Create DB.
        // initialise tables to be used.

        // Setup connection pool.
        bq = new BlockingQueue(5);
        bq.put(PostgresDBConnection.getDBConnection());
        bq.put(PostgresDBConnection.getDBConnection());
        bq.put(PostgresDBConnection.getDBConnection());
        bq.put(PostgresDBConnection.getDBConnection());

        // ensure DB name exists which is used in JDBC URL.
//        initialiseTable();
    }

    private void closeConnections() throws SQLException {
        for (int i = 0; i < bq.getCurrentSize(); i++) {
            Connection cn = (Connection) bq.takeIndex(i);
            cn.close();
        }
    }

    //

    synchronized private void initialiseTable() throws SQLException, InterruptedException {
//        String dropTableSql = "DROP TABLE accounts;";
        String createTableSql = "CREATE TABLE accounts(" +
                "  id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY," +
                "  number text UNIQUE," +
                "  client text," +
                "  amount numeric" +
                ");";

        String deleteAllDataSql = "DELETE FROM accounts where 1 = 1";

        String insertDataSql = "INSERT INTO accounts VALUES" +
                "  (1, '1001', 'alice', 1000.00)," +
                "  (2, '2001', 'bob', 100.00)," +
                "  (3, '2002', 'bob', 900.00);";

        Connection dbConn = (Connection) bq.take();
        Statement stmt = dbConn.createStatement();
//        stmt.execute(createTableSql);
        stmt.execute(deleteAllDataSql);
        stmt.execute(insertDataSql);
        stmt.close();
//        dbConn.commit();
        bq.put(dbConn);
    }

    /**
     * A helper method to run custom sql and print result.
     */
    private void printResultsFromRS(ResultSet rs, String threadName) throws SQLException {
        ResultSetMetaData rsmd = rs.getMetaData();
        int numCols = rsmd.getColumnCount();

        System.out.println("Result -- From - " + threadName);
        while (rs.next()) {
            StringBuilder row = new StringBuilder();
            for (int i = 1; i <= numCols; ++i) {
                row.append("\t").append(rs.getString(i));
            }
            System.out.println(row);
        }
    }

    /**
     * This method operates at the base(default) isolation verifies that dirty reads are not possible.
     * The base isolation is "read committed" because of MVCC.
     *
     * TR1 -> Begin | Updates | Reads (updated data) | Waits for 10 seconds | Commit.
     * TR2 -> Begin | Reads (No changes as data is Uncommitted | Waits for 15 seconds | Updated Data.
     */
    private void nonRepeatableReadFlow(int transactionLevel) throws InterruptedException {
        WaitGroup wg = new WaitGroup();
        Thread t1 = new Thread("Transaction 1") {
            public void run() {
                try {
                    wg.add();
                    String trx1Sql1 = "UPDATE accounts SET amount = amount - 200 WHERE client = 'alice';";
                    String trx2Sql2 = "SELECT * FROM accounts WHERE client = 'alice';";

                    Connection dbConn = (Connection) bq.take();
                    dbConn.setAutoCommit(false);
                    dbConn.setTransactionIsolation(transactionLevel);
                    Statement stmt = dbConn.createStatement();
                    stmt.execute(trx1Sql1);
                    ResultSet rs = stmt.executeQuery(trx2Sql2);
                    System.out.println("trx1; Should be able to see un-committed data.");

                    printResultsFromRS(rs, getName());

                    sleep(5000);
                    dbConn.commit();
                    rs.close();
                    stmt.close();
                    wg.done();
                    bq.put(dbConn);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
        };
        t1.start();

        Thread t2 = new Thread("Transaction 2") {
            @Override
            public void run() {
                try {
                    wg.add();
                    sleep(1000);
                    String trx2Sql = "SELECT * FROM accounts WHERE client = 'alice';";

                    Connection dbConn = (Connection) bq.take();
                    dbConn.setAutoCommit(false);
                    dbConn.setTransactionIsolation(transactionLevel);

                    Statement stmt = dbConn.createStatement();
                    System.out.println("trx2; Should not be able to see un-committed data.");

                    ResultSet rs = stmt.executeQuery(trx2Sql);
                    printResultsFromRS(rs, getName());

                    System.out.println("Sleeping to wait for transaction T1 to commit.");
                    sleep(10000);
                    System.out.println("trx2; Second select!!!!!");
                    rs = stmt.executeQuery(trx2Sql);
                    printResultsFromRS(rs, getName());

                    rs.close();
                    stmt.close();
                    dbConn.commit();
                    wg.done();
                    bq.put(dbConn);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
        };
        t2.start();
        wg.await();
    }


    public void phantomReadsIsolation(int transactionLevel) throws InterruptedException {
        WaitGroup wg = new WaitGroup();
        System.out.println("Phantom Read anomaly");

        Thread t1 = new Thread("Transaction 1") {
            @Override
            public void run() {
                try {
                    wg.add();
                    String trx1sql1 = "INSERT INTO accounts VALUES (4, '3001', 'charlie', 100.00);";
                    String trx1sql2 = "SELECT * FROM accounts ORDER BY id;";


                    Connection dbConn = (Connection) bq.take();
                    dbConn.setAutoCommit(false);
                    dbConn.setTransactionIsolation(transactionLevel);
                    Statement stmt = dbConn.createStatement();
                    stmt.execute(trx1sql1);
                    ResultSet rs = stmt.executeQuery(trx1sql2);
                    System.out.println("trx1; Should be able to see un-committed data.");

                    printResultsFromRS(rs, getName());
                    sleep(5000);

                    dbConn.commit();
                    rs.close();
                    stmt.close();
                    wg.done();
                    bq.put(dbConn);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
        };
        t1.start();

        Thread t2 = new Thread("Transaction 2") {
            @Override
            public void run() {
                try {
                    wg.add();
                    sleep(1000);
                    String trx2Sql = "SELECT * FROM accounts;";

                    Connection dbConn = (Connection) bq.take();
                    dbConn.setAutoCommit(false);
                    dbConn.setTransactionIsolation(transactionLevel);


                    Statement stmt = dbConn.createStatement();


                    ResultSet rs = stmt.executeQuery(trx2Sql);
                    printResultsFromRS(rs, getName());


                    sleep(8000);
                    System.out.println("Printing t1's state, to affirm that the transaction in there is complete.");
                    System.out.println(t1.getState());

                    System.out.println("Second select!!!!!");
                    rs = stmt.executeQuery(trx2Sql);
                    printResultsFromRS(rs, getName());

                    dbConn.commit();
                    rs.close();
                    stmt.close();
                    wg.done();
                    bq.put(dbConn);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
        };
        t2.start();
        wg.await();
    }

    private void inconsistentWrites(int transactionLevel) throws InterruptedException {

        WaitGroup wg = new WaitGroup();

        System.out.println("Inconsistent writes anomaly");

        Thread t1 = new Thread("Transaction 1") {
            @Override
            public void run() {
                try {
                    wg.add();

                    String trx1sql1 = "SELECT sum(amount) FROM accounts WHERE client = 'bob';";
                    String trx1sql2 = "UPDATE accounts SET amount = amount - 600.00 WHERE id = 2;";


                    Connection dbConn = (Connection) bq.take();
                    dbConn.setAutoCommit(false);
                    dbConn.setTransactionIsolation(transactionLevel);
                    Statement stmt = dbConn.createStatement();
                    ResultSet rs = stmt.executeQuery(trx1sql1);
                    printResultsFromRS(rs, getName());

                    sleep(2000);

                    stmt.execute(trx1sql2);

                    rs = stmt.executeQuery(trx1sql1);
                    printResultsFromRS(rs, getName());
                    System.out.println("trx1; Should be able to see un-committed data.");

                    sleep(6000);

                    dbConn.commit();

                    rs.close();
                    stmt.close();

                    wg.done();
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
        };
        t1.start();

        Thread t2 = new Thread("Transaction 2") {
            @Override
            public void run() {
                try {
                    wg.add();
                    sleep(500);
                    String trx2sql1 = "SELECT sum(amount) FROM accounts WHERE client = 'bob';";
                    String trx2sql2 = "UPDATE accounts SET amount = amount - 600.00 WHERE id = 3;";


                    Connection dbConn = (Connection) bq.take();
                    dbConn.setAutoCommit(false);
                    dbConn.setTransactionIsolation(transactionLevel);
                    Statement stmt = dbConn.createStatement();
                    ResultSet rs = stmt.executeQuery(trx2sql1);
                    printResultsFromRS(rs, getName());

                    sleep(4000);

                    stmt.execute(trx2sql2);

                    rs = stmt.executeQuery(trx2sql1);
                    printResultsFromRS(rs, getName());

                    dbConn.commit();
                    rs.close();
                    stmt.close();
                    wg.done();
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
        };
        t2.start();
        wg.await();
    }

    public static void main(String[] args) throws SQLException, InterruptedException {
        IsolationLevels il = new IsolationLevels();

        Utils.printSeparator(3);

        il.initialiseTable();
        System.out.println("Read committed Isolation (This is the default isolation level in postgres)");
        System.out.println("The second select in trx2 wil see updated data.");
        int transactionLevel = Connection.TRANSACTION_READ_COMMITTED;
        il.nonRepeatableReadFlow(transactionLevel);


        Utils.printSeparator(3);
        il.initialiseTable();
        System.out.println("Repeatable read Isolation.");
        System.out.println("The second select in trx2 wil NOT SEE updated data.");
        transactionLevel = Connection.TRANSACTION_REPEATABLE_READ;
        il.nonRepeatableReadFlow(transactionLevel);


        Utils.printSeparator(3);
        il.initialiseTable();
        System.out.println("Read committed Isolation.");
        System.out.println("The select in trx2 will see updated data.");
        transactionLevel = Connection.TRANSACTION_READ_COMMITTED;
        il.phantomReadsIsolation(transactionLevel);


        Utils.printSeparator(3);
        il.initialiseTable();
        System.out.println("Repeatable read Isolation.");
        System.out.println("The select in trx2 will NOT SEE updated data.");
        transactionLevel = Connection.TRANSACTION_REPEATABLE_READ;
        il.phantomReadsIsolation(transactionLevel);


        // This will raise exception such as -
        // Exception in thread "Transaction 1" java.lang.RuntimeException: org.postgresql.util.PSQLException:
        // ERROR: could not serialize access due to read/write dependencies among transactions
        Utils.printSeparator(3);
        il.initialiseTable();
        System.out.println("Serialisale Isolation.");
        System.out.println("The select in trx2 will NOT SEE updated data.");
        transactionLevel = Connection.TRANSACTION_SERIALIZABLE;
        il.inconsistentWrites(transactionLevel);


        il.closeConnections();

    }
}
